`timescale 1ns / 1ps

module hdmi_char_ip #
(
    parameter integer C_S_AXI_DATA_WIDTH = 32,
    parameter integer C_S_AXI_ADDR_WIDTH = 6
)
(
    // Clock/reset
    input  wire                       s_axi_aclk,
    input  wire                       s_axi_aresetn,

    // AXI4-Lite slave interface
    input  wire [C_S_AXI_ADDR_WIDTH-1:0] s_axi_awaddr,
    input  wire                       s_axi_awvalid,
    output wire                       s_axi_awready,
    input  wire [C_S_AXI_DATA_WIDTH-1:0] s_axi_wdata,
    input  wire [(C_S_AXI_DATA_WIDTH/8)-1:0] s_axi_wstrb,
    input  wire                       s_axi_wvalid,
    output wire                       s_axi_wready,
    output wire [1:0]                 s_axi_bresp,
    output wire                       s_axi_bvalid,
    input  wire [C_S_AXI_ADDR_WIDTH-1:0] s_axi_araddr,
    input  wire                       s_axi_arvalid,
    output wire                       s_axi_arready,
    output wire [C_S_AXI_DATA_WIDTH-1:0] s_axi_rdata,
    output wire [1:0]                 s_axi_rresp,
    output wire                       s_axi_rvalid,
    input  wire                       s_axi_rready,

    // Pixel clocks from Clock Wizard
    input  wire                       pix_clk,
    input  wire                       pix_clkx5,
    input  wire                       rst,

    // HDMI TMDS outputs
    output wire hdmi_clk_p,
    output wire hdmi_clk_n,
    output wire [2:0] hdmi_tx_p,
    output wire [2:0] hdmi_tx_n
);

    //--------------------------------------------
    // AXI-controlled registers
    //--------------------------------------------
    reg [6:0] ascii_reg   = 7'd65;    // default 'A'
    reg [9:0] loc_x_reg   = 10'd100;
    reg [9:0] loc_y_reg   = 10'd100;
    reg [23:0] ch_color_reg = 24'hFFFFFF; // white
    reg [23:0] bg_color_reg = 24'h000000; // black

    //--------------------------------------------
    // Simple AXI write logic
    //--------------------------------------------
    always @(posedge s_axi_aclk) begin
        if (!s_axi_aresetn) begin
            ascii_reg   <= 7'd65;
            loc_x_reg   <= 10'd100;
            loc_y_reg   <= 10'd100;
            ch_color_reg <= 24'hFFFFFF;
            bg_color_reg <= 24'h000000;
        end else begin
            if (s_axi_awvalid && s_axi_wvalid) begin
                case (s_axi_awaddr[5:2]) // word-aligned address
                    0: ascii_reg   <= s_axi_wdata[6:0];
                    1: loc_x_reg   <= s_axi_wdata[9:0];
                    2: loc_y_reg   <= s_axi_wdata[9:0];
                    3: ch_color_reg <= s_axi_wdata[23:0];
                    4: bg_color_reg <= s_axi_wdata[23:0];
                endcase
            end
        end
    end

    //--------------------------------------------
    // Tie-off AXI handshake signals
    //--------------------------------------------
    assign s_axi_awready = 1'b1;
    assign s_axi_wready  = 1'b1;
    assign s_axi_bresp   = 2'b00;
    assign s_axi_bvalid  = s_axi_awvalid & s_axi_wvalid;
    assign s_axi_arready = 1'b1;
    assign s_axi_rdata   = 32'd0; // readback not implemented
    assign s_axi_rresp   = 2'b00;
    assign s_axi_rvalid  = s_axi_arvalid;

    //--------------------------------------------
    // Instantiate display controller
    //--------------------------------------------
    disp_ctrl disp_inst (
        .pix_clk(pix_clk),
        .pix_clkx5(pix_clkx5),
        .rst(rst),
        .ascii(ascii_reg),
        .loc_x(loc_x_reg),
        .loc_y(loc_y_reg),
        .ch_color(ch_color_reg),
        .bg_color(bg_color_reg),
        .hdmi_clk_p(hdmi_clk_p),
        .hdmi_clk_n(hdmi_clk_n),
        .hdmi_tx_p(hdmi_tx_p),
        .hdmi_tx_n(hdmi_tx_n)
    );

endmodule
